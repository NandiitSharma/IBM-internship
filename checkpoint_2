!pip install dash dash-bootstrap-components plotly pandas scikit-learn joblib flask-caching prophet

This code sets up a Dash application for a FedEx KPI dashboard that includes various visualizations and suggestions based on KPIs. Here are some key points about the implementation:

1. **Data Loading and Caching**: The data is loaded from a CSV file and cached to improve performance.
2. **Machine Learning Model**: A linear regression model is trained to predict `Total_Cost`, and the model is periodically retrained in a background thread.
3. **KPI Mapping and Visualizations**: KPIs are mapped to stakeholders, and possible visualizations for each KPI are defined.
4. **Dash Layout**: The layout includes dropdowns for selecting stakeholders, KPIs, and visualizations, along with containers for displaying graphs and suggestions.
5. **Callbacks**: Callbacks update the available KPIs, visualizations, and graphs based on user selections. Suggestions for optimizing operations are generated based on the selected KPI and the filtered data.



  joblib Library
joblib is used for saving and loading machine learning models. This is useful for:

Model Persistence: You can save the trained model to a file and load it later without needing to retrain it every time.
Efficiency: It speeds up the deployment of the application since the model does not need to be retrained each time the app is restarted.
In the code:

joblib.dump(model, 'fedex_cost_prediction_model.pkl') saves the trained model to a file.
model = joblib.load('fedex_cost_prediction_model.pkl') loads the model from the file for making predictions.
threading Library
threading is used to run tasks in the background concurrently with the main program. This is useful for:

Background Processing: Performing time-consuming tasks without blocking the main application.
Concurrency: Allowing multiple operations to run simultaneously, which improves the responsiveness of the application.
In the code:

A separate thread is created to periodically retrain the model in the background without interrupting the main dashboard operations.
retrain_thread = threading.Thread(target=periodic_retrain, args=(3600,)) creates a new thread that runs the periodic_retrain function every 3600 seconds (1 hour).
retrain_thread.start() starts the thread.
time Library
time is used to handle time-related tasks. In this context, it's used for:

Delays: Introducing pauses in the execution of code.
Intervals: Creating periodic tasks by making the thread sleep for a specified interval before executing the next iteration of a loop.
In the code:

time.sleep(interval) in the periodic_retrain function causes the thread to sleep for interval seconds (1 hour in this case) before retraining the model again. This ensures that the model is retrained periodically.
How They Work Together
Training and Saving the Model: The model is trained initially and saved to a file using joblib.
Loading the Model: The saved model is loaded when needed for predictions.
Periodic Retraining: A separate thread is created using threading to periodically retrain the model. This thread sleeps for a specified interval (using time.sleep), retrains the model, and then repeats the process.
-------------------------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import joblib
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.express as px
import plotly.graph_objects as go
from flask_caching import Cache
import threading
import time

# Initialize Dash app
app = dash.Dash(__name__)
app.config.suppress_callback_exceptions = True

# Configure cache
cache = Cache(app.server, config={'CACHE_TYPE': 'simple'})
cache.init_app(app.server)

# Load and cache data
@cache.cached(timeout=50, key_prefix='all_data')
def get_data():
    file_path = '/content/Simulated-FedEx Dataset-Omnihole_Update.csv'
    data = pd.read_csv(file_path)
    data['Process_ID_Numeric'] = data['Process_ID'].str.extract(r'(\d+)').astype(int)
    return data

data = get_data()

# Prepare data for machine learning model
features = ['Cycle_Time', 'Employee_Productivity', 'Resource_Utilization', 'Damaged_Packages', 'Lost_Packages', 'Employee_Turnover_Rate', 'Training_Hours']
target = 'Total_Cost'
X = data[features]
y = data[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a linear regression model
def train_model():
    model = LinearRegression()
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    print(f"Mean Squared Error: {mse}")
    joblib.dump(model, 'fedex_cost_prediction_model.pkl')

train_model()

# Load the trained model
model = joblib.load('fedex_cost_prediction_model.pkl')

# Function to periodically retrain the model
def periodic_retrain(interval=3600):
    while True:
        time.sleep(interval)
        print("Retraining the model...")
        train_model()
        print("Model retrained successfully.")

# Start a background thread for periodic retraining
retrain_thread = threading.Thread(target=periodic_retrain, args=(3600,))
retrain_thread.daemon = True
retrain_thread.start()

# KPI mapping for stakeholders with geographical data
stakeholder_kpis = {
    'warehouse_manager': ['Cycle_Time', 'Total_Cost', 'Employee_Productivity', 'Resource_Utilization', 'Damaged_Packages', 'Lost_Packages', 'Employee_Turnover_Rate', 'Training_Hours', 'City', 'State', 'Latitude', 'Longitude'],
    'delivery_agent': ['Delivery_Time', 'On_Time_Delivery', 'Fuel_Consumption', 'Customer_Complaints', 'Late_Deliveries', 'City', 'State', 'Latitude', 'Longitude'],
    'logistics_manager': data.columns.tolist(),
    'general_manager': data.columns.tolist(),
    'marketing_head': ['Customer_Satisfaction', 'On_Time_Delivery', 'Customer_Complaints', 'City', 'State', 'Latitude', 'Longitude'],
    'administration_head': ['Total_Cost', 'Vehicle_Maintenance_Cost', 'Employee_Turnover_Rate', 'Training_Hours', 'City', 'State', 'Latitude', 'Longitude']
}

# Define applicable visualization types for each KPI
kpi_visualizations = {
    'Cycle_Time': ['Line Chart', 'Scatter Plot', 'Bar Chart', 'Heatmap', 'Bubble Chart', 'Comparative Analysis'],
    'Total_Cost': ['Line Chart', 'Bar Chart', 'Pie Chart', 'Heatmap', 'Comparative Analysis'],
    'Employee_Productivity': ['Line Chart', 'Scatter Plot', 'Radar Chart', 'Comparative Analysis'],
    'Resource_Utilization': ['Pie Chart', 'Bar Chart', 'Comparative Analysis'],
    'Damaged_Packages': ['Bar Chart', 'Comparative Analysis'],
    'Lost_Packages': ['Bar Chart', 'Comparative Analysis'],
    'Employee_Turnover_Rate': ['Line Chart', 'Scatter Plot', 'Radar Chart', 'Comparative Analysis'],
    'Training_Hours': ['Line Chart', 'Bar Chart', 'Funnel Chart', 'Comparative Analysis'],
    'Delivery_Time': ['Line Chart', 'Scatter Plot', 'Bubble Chart', 'Comparative Analysis'],
    'On_Time_Delivery': ['Line Chart', 'Bar Chart', 'Comparative Analysis'],
    'Fuel_Consumption': ['Line Chart', 'Scatter Plot', 'Bubble Chart', 'Comparative Analysis'],
    'Customer_Complaints': ['Line Chart', 'Bar Chart', 'Tree Map', 'Comparative Analysis'],
    'Late_Deliveries': ['Bar Chart', 'Comparative Analysis'],
    'Customer_Satisfaction': ['Line Chart', 'Pie Chart', 'Comparative Analysis'],
    'Vehicle_Maintenance_Cost': ['Line Chart', 'Bar Chart', 'Comparative Analysis'],
    'City': ['Map'],
    'State': ['Map'],
    'Latitude': ['Map'],
    'Longitude': ['Map']
}

# Define the CSS styles for the dashboard
app.layout = html.Div([
    html.H1("FedEx KPI Dashboard", style={'textAlign': 'center', 'color': 'white', 'background-color': '#0074D9', 'padding': '20px', 'border': '2px solid black'}),
    dcc.Dropdown(
        id='stakeholder-dropdown',
        options=[
            {'label': 'Warehouse Manager', 'value': 'warehouse_manager'},
            {'label': 'Delivery Agent', 'value': 'delivery_agent'},
            {'label': 'Logistics Manager', 'value': 'logistics_manager'},
            {'label': 'General Manager', 'value': 'general_manager'},
            {'label': 'Marketing Head', 'value': 'marketing_head'},
            {'label': 'Administration Head', 'value': 'administration_head'}
        ],
        value='warehouse_manager',
        style={'width': '50%', 'margin': 'auto'}
    ),
    html.Br(),
    html.Label("Select Process ID Range:"),
    dcc.RangeSlider(
        id='process-id-slider',
        min=data['Process_ID_Numeric'].min(),
        max=data['Process_ID_Numeric'].max(),
        value=[data['Process_ID_Numeric'].min(), data['Process_ID_Numeric'].max()],
        marks={i: str(i) for i in range(data['Process_ID_Numeric'].min(), data['Process_ID_Numeric'].max() + 1, 50)},  # Increased interval to 50
        step=1,
        allowCross=False
    ),
    dcc.Tabs(id='kpi-tabs'),
    html.Br(),
    dcc.Dropdown(id='visualization-dropdown', style={'width': '50%', 'margin': 'auto'}),
    html.Div(id='second-kpi-container', style={'display': 'none'}, children=[
        html.Label("Select Second KPI for Comparison:"),
        dcc.Dropdown(id='second-kpi-dropdown', style={'width': '50%', 'margin': 'auto'})
    ]),
    html.Div(id='graphs-container', style={'margin-top': '20px', 'border': '2px solid black', 'padding': '10px', 'background-color': '#f0f0f0'}),
    html.Div(id='details-container', style={'margin-top': '20px', 'border': '2px solid black', 'padding': '10px', 'background-color': '#f0f0f0', 'display': 'none'}),
])

# Callback to update KPI tabs based on selected stakeholder
@app.callback(
    Output('kpi-tabs', 'children'),
    [Input('stakeholder-dropdown', 'value')]
)
def update_kpi_tabs(stakeholder):
    kpis = stakeholder_kpis.get(stakeholder, [])
    return [dcc.Tab(label=kpi.replace('_', ' '), value=kpi) for kpi in kpis]

# Callback to update visualization dropdown based on selected KPI
@app.callback(
    [Output('visualization-dropdown', 'options'),
     Output('second-kpi-container', 'style')],
    [Input('kpi-tabs', 'value')]
)
def update_visualization_options(selected_kpi):
    if selected_kpi:
        visualizations = kpi_visualizations.get(selected_kpi, [])
        if 'Comparative Analysis' in visualizations:
            return [{'label': viz, 'value': viz} for viz in visualizations], {'display': 'block'}
        return [{'label': viz, 'value': viz} for viz in visualizations], {'display': 'none'}
    return [], {'display': 'none'}

# Callback to update second KPI dropdown for comparative analysis
@app.callback(
    Output('second-kpi-dropdown', 'options'),
    [Input('stakeholder-dropdown', 'value')]
)
def update_second_kpi_dropdown(stakeholder):
    kpis = stakeholder_kpis.get(stakeholder, [])
    return [{'label': kpi.replace('_', ' '), 'value': kpi} for kpi in kpis]

# Function to generate suggestions
def generate_suggestions(selected_kpi, filtered_data_before, filtered_data_after):
    suggestions = []
    if selected_kpi == 'Cycle_Time':
        avg_cycle_time_before = filtered_data_before[selected_kpi].mean()
        avg_cycle_time_after = filtered_data_after[selected_kpi].mean()
        if avg_cycle_time_after < avg_cycle_time_before:
            suggestions.append("Cycle Time has decreased after BPR implementation. Continue optimizing the processes to further reduce Cycle Time.")
        else:
            suggestions.append("Cycle Time has increased after BPR implementation. Investigate the causes and implement corrective measures.")
    elif selected_kpi == 'Total_Cost':
        avg_total_cost_before = filtered_data_before[selected_kpi].mean()
        avg_total_cost_after = filtered_data_after[selected_kpi].mean()
        if avg_total_cost_after < avg_total_cost_before:
            suggestions.append("Total Cost has decreased after BPR implementation. Consider reinvesting the savings into further improvements.")
        else:
            suggestions.append("Total Cost has increased after BPR implementation. Analyze the cost drivers and find ways to cut unnecessary expenses.")
    elif selected_kpi == 'Employee_Productivity':
        avg_employee_productivity_before = filtered_data_before[selected_kpi].mean()
        avg_employee_productivity_after = filtered_data_after[selected_kpi].mean()
        if avg_employee_productivity_after > avg_employee_productivity_before:
            suggestions.append("Employee Productivity has improved after BPR implementation. Encourage continuous training and motivation to maintain high productivity.")
        else:
            suggestions.append("Employee Productivity has decreased after BPR implementation. Identify the factors affecting productivity and address them promptly.")
    elif selected_kpi == 'Resource_Utilization':
        avg_resource_utilization_before = filtered_data_before[selected_kpi].mean()
        avg_resource_utilization_after = filtered_data_after[selected_kpi].mean()
        if avg_resource_utilization_after > avg_resource_utilization_before:
            suggestions.append("Resource Utilization has increased after BPR implementation. Optimize resource allocation to further enhance utilization.")
        else:
            suggestions.append("Resource Utilization has decreased after BPR implementation. Re-evaluate resource allocation and improve efficiency.")
    elif selected_kpi == 'Damaged_Packages':
        avg_damaged_packages_before = filtered_data_before[selected_kpi].mean()
        avg_damaged_packages_after = filtered_data_after[selected_kpi].mean()
        if avg_damaged_packages_after < avg_damaged_packages_before:
            suggestions.append("The number of damaged packages has decreased after BPR implementation. Maintain the current packaging and handling standards.")
        else:
            suggestions.append("The number of damaged packages has increased after BPR implementation. Investigate the causes and improve packaging and handling processes.")
    elif selected_kpi == 'Lost_Packages':
        avg_lost_packages_before = filtered_data_before[selected_kpi].mean()
        avg_lost_packages_after = filtered_data_after[selected_kpi].mean()
        if avg_lost_packages_after < avg_lost_packages_before:
            suggestions.append("The number of lost packages has decreased after BPR implementation. Keep up the effective tracking and handling measures.")
        else:
            suggestions.append("The number of lost packages has increased after BPR implementation. Enhance package tracking and handling procedures.")
    elif selected_kpi == 'Employee_Turnover_Rate':
        avg_employee_turnover_rate_before = filtered_data_before[selected_kpi].mean()
        avg_employee_turnover_rate_after = filtered_data_after[selected_kpi].mean()
        if avg_employee_turnover_rate_after < avg_employee_turnover_rate_before:
            suggestions.append("Employee Turnover Rate has decreased after BPR implementation. Continue to foster a positive work environment.")
        else:
            suggestions.append("Employee Turnover Rate has increased after BPR implementation. Investigate the reasons and improve employee satisfaction and retention.")
    elif selected_kpi == 'Training_Hours':
        avg_training_hours_before = filtered_data_before[selected_kpi].mean()
        avg_training_hours_after = filtered_data_after[selected_kpi].mean()
        if avg_training_hours_after > avg_training_hours_before:
            suggestions.append("Training Hours have increased after BPR implementation. Ensure that training programs are effective and align with business goals.")
        else:
            suggestions.append("Training Hours have decreased after BPR implementation. Evaluate the impact and consider increasing training opportunities for employees.")
    elif selected_kpi == 'Delivery_Time':
        avg_delivery_time_before = filtered_data_before[selected_kpi].mean()
        avg_delivery_time_after = filtered_data_after[selected_kpi].mean()
        if avg_delivery_time_after < avg_delivery_time_before:
            suggestions.append("Delivery Time has decreased after BPR implementation. Continue optimizing delivery routes and processes.")
        else:
            suggestions.append("Delivery Time has increased after BPR implementation. Identify the bottlenecks and streamline the delivery process.")
    elif selected_kpi == 'On_Time_Delivery':
        avg_on_time_delivery_before = filtered_data_before[selected_kpi].mean()
        avg_on_time_delivery_after = filtered_data_after[selected_kpi].mean()
        if avg_on_time_delivery_after > avg_on_time_delivery_before:
            suggestions.append("On-Time Delivery has improved after BPR implementation. Maintain the current efficiency and consider further improvements.")
        else:
            suggestions.append("On-Time Delivery has decreased after BPR implementation. Analyze the reasons and take corrective actions to improve delivery timeliness.")
    elif selected_kpi == 'Fuel_Consumption':
        avg_fuel_consumption_before = filtered_data_before[selected_kpi].mean()
        avg_fuel_consumption_after = filtered_data_after[selected_kpi].mean()
        if avg_fuel_consumption_after < avg_fuel_consumption_before:
            suggestions.append("Fuel Consumption has decreased after BPR implementation. Continue optimizing routes and vehicle usage.")
        else:
            suggestions.append("Fuel Consumption has increased after BPR implementation. Investigate the causes and implement measures to improve fuel efficiency.")
    elif selected_kpi == 'Customer_Complaints':
        avg_customer_complaints_before = filtered_data_before[selected_kpi].mean()
        avg_customer_complaints_after = filtered_data_after[selected_kpi].mean()
        if avg_customer_complaints_after < avg_customer_complaints_before:
            suggestions.append("Customer Complaints have decreased after BPR implementation. Maintain the high level of customer service.")
        else:
            suggestions.append("Customer Complaints have increased after BPR implementation. Address the issues and improve customer satisfaction.")
    elif selected_kpi == 'Late_Deliveries':
        avg_late_deliveries_before = filtered_data_before[selected_kpi].mean()
        avg_late_deliveries_after = filtered_data_after[selected_kpi].mean()
        if avg_late_deliveries_after < avg_late_deliveries_before:
            suggestions.append("Late Deliveries have decreased after BPR implementation. Continue to ensure timely deliveries.")
        else:
            suggestions.append("Late Deliveries have increased after BPR implementation. Identify the reasons and take corrective actions to ensure timely deliveries.")
    elif selected_kpi == 'Customer_Satisfaction':
        avg_customer_satisfaction_before = filtered_data_before[selected_kpi].mean()
        avg_customer_satisfaction_after = filtered_data_after[selected_kpi].mean()
        if avg_customer_satisfaction_after > avg_customer_satisfaction_before:
            suggestions.append("Customer Satisfaction has improved after BPR implementation. Maintain the high level of service quality.")
        else:
            suggestions.append("Customer Satisfaction has decreased after BPR implementation. Identify the causes and improve service quality.")
    elif selected_kpi == 'Vehicle_Maintenance_Cost':
        avg_vehicle_maintenance_cost_before = filtered_data_before[selected_kpi].mean()
        avg_vehicle_maintenance_cost_after = filtered_data_after[selected_kpi].mean()
        if avg_vehicle_maintenance_cost_after < avg_vehicle_maintenance_cost_before:
            suggestions.append("Vehicle Maintenance Cost has decreased after BPR implementation. Continue to maintain the vehicles efficiently.")
        else:
            suggestions.append("Vehicle Maintenance Cost has increased after BPR implementation. Investigate the reasons and optimize the maintenance processes.")

    return suggestions

# Callback to update graphs and suggestions based on dropdown selection and range slider
@app.callback(
    [Output('graphs-container', 'children'),
     Output('details-container', 'children'),
     Output('details-container', 'style')],
    [Input('stakeholder-dropdown', 'value'),
     Input('process-id-slider', 'value'),
     Input('kpi-tabs', 'value'),
     Input('visualization-dropdown', 'value'),
     Input('second-kpi-dropdown', 'value')]
)
def update_graphs_and_suggestions(stakeholder, process_id_range, selected_kpi, selected_visualization, second_kpi):
    try:
        # Filter data for selected range
        filtered_data = data[(data['Process_ID_Numeric'] >= process_id_range[0]) & (data['Process_ID_Numeric'] <= process_id_range[1])]

        # Filter data for 'Before' BPR implementation
        filtered_data_before = filtered_data[filtered_data['BPR_Implementation'] == 'Before']

        # Filter data for 'After' BPR implementation
        filtered_data_after = filtered_data[filtered_data['BPR_Implementation'] == 'After']

        if not selected_kpi or not selected_visualization:
            return [], "", {'display': 'none'}

        if selected_visualization == 'Comparative Analysis':
            if not second_kpi:
                return [], "", {'display': 'none'}
            fig_before = px.scatter(filtered_data_before, x=selected_kpi, y=second_kpi, title=f'Comparative Analysis of {selected_kpi.replace("_", " ")} and {second_kpi.replace("_", " ")} - Before')
            fig_after = px.scatter(filtered_data_after, x=selected_kpi, y=second_kpi, title=f'Comparative Analysis of {selected_kpi.replace("_", " ")} and {second_kpi.replace("_", " ")} - After')
        else:
            if selected_visualization == 'Line Chart':
                fig_before = px.line(filtered_data_before, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.line(filtered_data_after, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Scatter Plot':
                fig_before = px.scatter(filtered_data_before, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.scatter(filtered_data_after, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Bar Chart':
                fig_before = px.bar(filtered_data_before, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.bar(filtered_data_after, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Pie Chart' and selected_kpi in ['Resource_Utilization', 'Total_Cost', 'Customer_Satisfaction']:
                fig_before = px.pie(filtered_data_before, names='Process_ID', values=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.pie(filtered_data_after, names='Process_ID', values=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Heatmap':
                fig_before = px.density_heatmap(filtered_data_before, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.density_heatmap(filtered_data_after, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Bubble Chart':
                fig_before = px.scatter(filtered_data_before, x='Process_ID', y=selected_kpi, size=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.scatter(filtered_data_after, x='Process_ID', y=selected_kpi, size=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Radar Chart':
                categories = filtered_data_before['Process_ID'].tolist()
                fig_before = go.Figure()
                fig_before.add_trace(go.Scatterpolar(
                    r=filtered_data_before[selected_kpi].tolist(),
                    theta=categories,
                    fill='toself',
                    name='Before'
                ))
                fig_before.update_layout(
                    polar=dict(
                        radialaxis=dict(
                            visible=True,
                            range=[0, max(filtered_data[selected_kpi].max(), 1)]
                        )),
                    title=f'{selected_kpi.replace("_", " ")} - Before'
                )
                fig_after = go.Figure()
                fig_after.add_trace(go.Scatterpolar(
                    r=filtered_data_after[selected_kpi].tolist(),
                    theta=categories,
                    fill='toself',
                    name='After'
                ))
                fig_after.update_layout(
                    polar=dict(
                        radialaxis=dict(
                            visible=True,
                            range=[0, max(filtered_data[selected_kpi].max(), 1)]
                        )),
                    title=f'{selected_kpi.replace("_", " ")} - After'
                )
            elif selected_visualization == 'Funnel Chart':
                fig_before = px.funnel(filtered_data_before, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.funnel(filtered_data_after, x='Process_ID', y=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Tree Map':
                fig_before = px.treemap(filtered_data_before, path=['Process_ID'], values=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - Before')
                fig_after = px.treemap(filtered_data_after, path=['Process_ID'], values=selected_kpi, title=f'{selected_kpi.replace("_", " ")} - After')
            elif selected_visualization == 'Map' and selected_kpi in ['City', 'State']:
                # Map visualization based on City and State
                fig_before = px.scatter_mapbox(
                    filtered_data_before,
                    lat='Latitude',
                    lon='Longitude',
                    hover_name=selected_kpi,
                    color=selected_kpi,
                    title=f'{selected_kpi.replace("_", " ")} - Before',
                    mapbox_style="carto-positron"
                )
                fig_after = px.scatter_mapbox(
                    filtered_data_after,
                    lat='Latitude',
                    lon='Longitude',
                    hover_name=selected_kpi,
                    color=selected_kpi,
                    title=f'{selected_kpi.replace("_", " ")} - After',
                    mapbox_style="carto-positron"
                )
            elif selected_visualization == 'Map' and selected_kpi in ['Latitude', 'Longitude']:
                # Map visualization based on Latitude and Longitude
                fig_before = px.scatter_mapbox(
                    filtered_data_before,
                    lat='Latitude',
                    lon='Longitude',
                    color=selected_kpi,
                    title=f'{selected_kpi.replace("_", " ")} - Before',
                    mapbox_style="carto-positron"
                )
                fig_after = px.scatter_mapbox(
                    filtered_data_after,
                    lat='Latitude',
                    lon='Longitude',
                    color=selected_kpi,
                    title=f'{selected_kpi.replace("_", " ")} - After',
                    mapbox_style="carto-positron"
                )
            else:
                fig_before = None
                fig_after = None

        graphs = []
        if fig_before and fig_after:
            graphs = [
                dcc.Graph(figure=fig_before),
                dcc.Graph(figure=fig_after)
            ]

        # Generate suggestions based on selected KPI
        suggestions = generate_suggestions(selected_kpi, filtered_data_before, filtered_data_after)
        suggestions_html = html.Ul([html.Li(suggestion) for suggestion in suggestions])

        # Show details container if a tab is selected
        details_style = {'margin-top': '20px', 'border': '2px solid black', 'padding': '10px', 'background-color': '#f0f0f0'}
        if selected_kpi:
            details_style['display'] = 'block'
        else:
            details_style['display'] = 'none'

        return graphs, suggestions_html, details_style

    except Exception as e:
        print(f"Error: {e}")
        return [], "", {'display': 'none'}

# Endpoint to handle real-time data
@app.server.route('/predict', methods=['POST'])
def predict():
    import json
    from flask import request, jsonify

    try:
        # Get data from POST request
        data = request.get_json(force=True)
        X_real_time = pd.DataFrame([data])

        # Load the trained model
        model = joblib.load('fedex_cost_prediction_model.pkl')

        # Predict
        prediction = model.predict(X_real_time[features])
        return jsonify({'prediction': prediction[0]})
    except Exception as e:
        return jsonify({'error': str(e)})

if __name__ == '__main__':
   app.run_server(debug=True, port=8052)  # Changed port to 8052
------------------------------------------------------------------------------------------------------------------
